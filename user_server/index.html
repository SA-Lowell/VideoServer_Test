<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Video Receiver</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0px;
            background-color: #f0f0f0;
        }
        video {
            width: 100%;
            height: 100%;
            background-color: black;
        }
        input, button, select {
            margin: 5px;
            padding: 5px;
        }
        #log {
            white-space: pre-wrap;
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
    <video id="video" autoplay playsinline controls></video>
    <div style="margin: 0px 20px">
        <button onclick="togglePlayPause()">Play/Pause</button>
        <input type="text" id="serverUrl" placeholder="Server URL (e.g., http://192.168.0.60:8081/signal)" value="http://192.168.0.60:8081/signal">
        <select id="station">
            <option value="">Loading stations...</option>
        </select>
        <label><input type="checkbox" id="adsEnabled" checked> Enable Ads</label>
        <button onclick="startConnection()">Send Offer to Server</button>
        <button onclick="restartICE()">Restart ICE</button>
    </div>
    <pre id="log"></pre>

<script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }
</script>

<script>
let pc = null;
let audioContext = null;
let staticAudioNode = null;
let analyser = null;
let source = null;
let lastVideoTime = 0;
let lastCheckTime = 0;
let freezeCount = 0;
const maxFreezeRestarts = 5; // Increased from 3
const videoElement = document.getElementById('video');
const logElement = document.getElementById('log');

window.addEventListener('load', async () => {
    try {
        const response = await fetch('/api/stations');
        if (!response.ok) throw new Error('Failed to fetch stations');
        const stations = await response.json();
        const select = document.getElementById('station');
        select.innerHTML = '';
        stations.forEach(station => {
            const option = document.createElement('option');
            option.value = station;
            option.textContent = station;
            if (station === "Malcolm in the Middle") option.selected = true;
            select.appendChild(option);
        });
        log('Loaded stations: ' + stations.join(', '));
    } catch (error) {
        log('Error loading stations: ' + error);
        const fallbackStations = ["Bob's Burgers", "Malcolm in the Middle", "3rd Rock from the Sun", "Beyond Belief Fact or Fiction"];
        const select = document.getElementById('station');
        fallbackStations.forEach(station => {
            const option = document.createElement('option');
            option.value = station;
            option.textContent = station;
            if (station === "Malcolm in the Middle") option.selected = true;
            select.appendChild(option);
        });
        log('Using fallback stations: ' + fallbackStations.join(', '));
    }
});

function log(message) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] ${message}`);
    logElement.textContent += `[${timestamp}] ${message}\n`;
    logElement.scrollTop = logElement.scrollHeight;
}

async function getStatsPeriodically() {
    if (!pc || pc.connectionState !== 'connected') return;
    try {
        const stats = await pc.getStats();
        stats.forEach(report => {
            if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                log(`Audio stats: packetsReceived=${report.packetsReceived || 0}, packetsLost=${report.packetsLost || 0}, jitter=${report.jitter || 0}, audioLevel=${report.audioLevel || 0}`);
                if (report.packetsLost > 0) log(`Warning: Audio packet loss detected: ${report.packetsLost}`);
                if (report.jitter > 0.2) log(`Warning: High audio jitter detected: ${report.jitter}`);
            }
            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                log(`Video stats: packetsReceived=${report.packetsReceived || 0}, packetsLost=${report.packetsLost || 0}, jitter=${report.jitter || 0}, framesDecoded=${report.framesDecoded || 0}`);
                if (report.packetsLost > 0) log(`Warning: Video packet loss detected: ${report.packetsLost}`);
                if (report.jitter > 0.2) log(`Warning: High video jitter detected: ${report.jitter}`);
            }
            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                log(`Active candidate pair: localType=${report.localCandidateId}, remoteType=${report.remoteCandidateId}, bytesSent=${report.bytesSent}, bytesReceived=${report.bytesReceived}, roundTripTime=${report.currentRoundTripTime || 0}`);
            }
        });
    } catch (err) {
        log(`Error getting stats: ${err}`);
    }
    setTimeout(getStatsPeriodically, 2000);
}

function createTVStaticEffect() {
    const canvas = document.createElement('canvas');
    canvas.width = 640;
    canvas.height = 360;
    const ctx = canvas.getContext('2d');
    let animationFrameId = null;
    videoElement.srcObject = canvas.captureStream(30);
    log('Starting TV static effect');
    function drawStatic() {
        const imageData = ctx.createImageData(canvas.width, canvas.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 255;
            imageData.data[i] = noise;
            imageData.data[i + 1] = noise;
            imageData.data[i + 2] = noise;
            imageData.data[i + 3] = 255;
        }
        ctx.putImageData(imageData, 0, 0);
        animationFrameId = requestAnimationFrame(drawStatic);
    }
    drawStatic();
    return () => {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            log('Stopped TV static effect');
        }
    };
}

function startStaticAudio() {
    if (!audioContext || audioContext.state === 'closed') {
        audioContext = new AudioContext({ sampleRate: 48000 });
    }
    const bufferSize = audioContext.sampleRate * 2;
    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.1;
    }
    const source = audioContext.createBufferSource();
    source.buffer = buffer;
    source.loop = true;
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start();
    log('Starting static audio');
    staticAudioNode = source;
}

function stopStaticAudio() {
    if (staticAudioNode) {
        staticAudioNode.stop();
        staticAudioNode = null;
        log('Stopping static audio');
    }
}

function togglePlayPause() {
    if (videoElement.paused) {
        videoElement.play().then(() => {
            log('Video playback resumed');
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => log('AudioContext resumed for analysis'));
            }
        }).catch(err => log(`Video playback error: ${err}`));
    } else {
        videoElement.pause();
        log('Video playback paused');
        if (audioContext && audioContext.state === 'running') {
            audioContext.suspend().then(() => log('AudioContext suspended'));
        }
    }
}

async function startConnection() {
    if (pc) {
        pc.close();
        log('Closed existing PeerConnection');
        pc = null;
        if (audioContext) {
            audioContext.close().then(() => {
                log('Closed existing AudioContext');
                audioContext = null;
                analyser = null;
                source = null;
            });
        }
    }
    freezeCount = 0;
    const stopStaticEffect = createTVStaticEffect();
    startStaticAudio();
    pc = new RTCPeerConnection({
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
            { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
            { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
        ],
        iceTransportPolicy: 'all',
        iceCandidatePoolSize: 10
    });
    let remoteStream = null;
    pc.ontrack = event => {
        const track = event.track;
        log(`Track received: kind=${track.kind}, id=${track.id}, readyState=${track.readyState}, enabled=${track.enabled}, muted=${track.muted}`);
        if (!remoteStream) {
            remoteStream = event.streams[0];
            log('Initialized remoteStream with first track');
        }
        if (track.kind === 'video') {
            videoElement.srcObject = remoteStream;
            stopStaticAudio();
            stopStaticEffect();
            log('Video started playing');
            videoElement.play().then(() => {
                log('Video playback started');
                log(`Video element state: paused=${videoElement.paused}, ended=${videoElement.ended}, error=${videoElement.error ? videoElement.error.message : 'none'}`);
            }).catch(err => log(`Video playback error: ${err}`));
            track.onunmute = () => log(`Video unmuted - media flowing`);
            track.onmute = () => {
                log(`Video track muted: id=${track.id} - possible no media flow`);
                setTimeout(() => {
                    if (track.muted && freezeCount < maxFreezeRestarts) {
                        log('Video track still muted, scheduling ICE restart');
                        setTimeout(restartICE, 5000); // Reduced from 10000
                    }
                }, 2000);
            };
            track.onended = () => log(`Video track ended: id=${track.id}`);
        }
        if (track.kind === 'audio') {
            if (!audioContext || audioContext.state === 'closed') {
                audioContext = new AudioContext({ sampleRate: 48000 });
                log('Created new AudioContext for analysis');
            }
            if (source) {
                source.disconnect();
                analyser.disconnect();
                log(`Disconnected previous audio source for analysis`);
            }
            source = audioContext.createMediaStreamSource(new MediaStream([track]));
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            const delayNode = audioContext.createDelay(0.5); // Increased to 500ms
            source.connect(delayNode);
            delayNode.connect(analyser);
            analyser.connect(audioContext.destination);
            log(`Connected audio track to AnalyserNode with 500ms jitter buffer, sampleRate=${audioContext.sampleRate}, channels=${source.channelCount}`);
            track.onunmute = () => {
                log(`Audio track unmuted: id=${track.id} - media flowing`);
                const data = new Float32Array(analyser.fftSize);
                analyser.getFloatTimeDomainData(data);
                log('Audio data sample on unmute: ' + data.slice(0, 10).join(', '));
            };
            track.onmute = () => log(`Audio track muted: id=${track.id} - possible silence or no media flow`);
            track.onended = () => log(`Audio track ended: id=${track.id}`);
        }
    };
    pc.onicecandidate = event => {
        if (event.candidate) {
            log(`New ICE candidate: ${JSON.stringify(event.candidate)}`);
        } else {
            log('All ICE candidates gathered (end-of-candidates)');
        }
    };
    pc.onicecandidateerror = event => {
        log(`ICE candidate error: ${JSON.stringify(event)}`);
    };
    pc.onnegotiationneeded = () => {
        log('Negotiation needed');
    };
    pc.oniceconnectionstatechange = () => {
        log(`ICE connection state: ${pc.iceConnectionState}`);
        if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
            log('ICE connected - stream active');
            setTimeout(getStatsPeriodically, 1000);
            freezeCount = 0;
        }
        if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
            if (freezeCount < maxFreezeRestarts) {
                log(`ICE ${pc.iceConnectionState} - scheduling restart in 5 seconds...`);
                setTimeout(() => {
                    if (pc && (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed')) {
                        restartICE();
                    }
                }, 5000); // Reduced from 10000
            } else {
                log('Max ICE restarts reached, reconnecting fully');
                startConnection();
            }
        }
    };
    pc.onconnectionstatechange = () => {
        log(`Peer connection state: ${pc.connectionState}`);
        if (pc.connectionState === 'failed') {
            log('Peer connection failed - scheduling ICE restart');
            setTimeout(restartICE, 5000); // Reduced from 10000
        }
    };
    videoElement.addEventListener('error', () => {
        log(`Video element error: ${videoElement.error ? videoElement.error.message : 'Unknown error'}`);
    });
    videoElement.addEventListener('stalled', () => {
        log('Video stalled - scheduling ICE restart in 5 seconds');
        setTimeout(() => {
            if (pc && (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed')) {
                restartICE();
            }
        }, 5000); // Reduced from 10000
    });
    videoElement.addEventListener('waiting', () => {
        log('Video waiting for data - checking connection state');
        if (pc && (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed')) {
            setTimeout(restartICE, 5000); // Reduced from 10000
        }
    });
function checkForDesync() {
    if (!videoElement.srcObject || videoElement.paused || videoElement.ended) return;
    const now = performance.now() / 1000;
    const videoTime = videoElement.currentTime;
    const elapsed = now - lastCheckTime;
    if (elapsed > 5) {
        const timeDiff = Math.abs(videoTime - lastVideoTime - elapsed);
        if (Math.abs(videoTime - lastVideoTime) < 1.5 && !videoElement.paused) {
            log(`Video freeze detected: currentTime=${videoTime}, lastTime=${lastVideoTime}, elapsed=${elapsed.toFixed(3)}s`);
            freezeCount++;
            if (freezeCount >= maxFreezeRestarts) {
                log('Max freeze restarts reached, reconnecting fully');
                startConnection();
                freezeCount = 0;
            } else {
                log('Scheduling ICE restart due to freeze');
                setTimeout(restartICE, 5000);
            }
        } else if (analyser && timeDiff > 3.0) { // Increased threshold to 3s
            const data = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(data);
            const level = data.reduce((sum, val) => sum + Math.abs(val), 0) / data.length;
            log(`Audio-video desync check: videoTime=${videoTime}, expected=${(lastVideoTime + elapsed).toFixed(3)}, diff=${timeDiff.toFixed(3)}s, audioLevel=${level.toFixed(4)}`);
            if (level < 0.001) {
                log('Warning: Audio level very low, possible silence or decoding issue');
            } else if (timeDiff > 5.0) { // Only restart for significant desync
                log(`Significant audio-video desync detected: diff=${timeDiff.toFixed(3)}s`);
                freezeCount++;
                if (freezeCount >= maxFreezeRestarts) {
                    log('Max desync restarts reached, reconnecting fully');
                    startConnection();
                    freezeCount = 0;
                } else {
                    log('Scheduling ICE restart due to desync');
                    setTimeout(restartICE, 5000);
                }
            }
        }
        // Log decoding performance
        pc.getStats().then(stats => {
            stats.forEach(report => {
                if (report.type === 'inbound-rtp' && report.kind === 'video') {
                    log(`Decoding performance: framesDecoded=${report.framesDecoded || 0}, fps=${report.framesPerSecond || 0}, jitter=${report.jitter || 0}`);
                }
            });
        });
        lastVideoTime = videoTime;
        lastCheckTime = now;
    }
}
    setInterval(checkForDesync, 5000);
    const audioTransceiver = pc.addTransceiver('audio', { direction: 'recvonly' });
    const videoTransceiver = pc.addTransceiver('video', {
        direction: 'recvonly',
        receiveCodecs: [
            {
                mimeType: 'video/H264',
                sdpFmtpLine: 'level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640034',
            }
        ]
    });
    try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        log(`Local Offer SDP:\n${offer.sdp}`);
        const serverUrl = document.getElementById('serverUrl').value;
        const station = document.getElementById('station').value;
        const adsEnabled = document.getElementById('adsEnabled').checked;
        const response = await fetch(`${serverUrl}?station=${encodeURIComponent(station)}&adsEnabled=${adsEnabled}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(offer)
        });
        if (response.ok) {
            const answer = await response.json();
            log(`Remote Answer SDP:\n${answer.sdp}`);
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
        } else {
            log(`Error sending offer: ${response.statusText}`);
        }
    } catch (error) {
        log(`Error starting connection: ${error}`);
    }
}

async function restartICE() {
    if (!pc || pc.connectionState === 'closed') {
        log('PeerConnection closed or null, starting new connection');
        startConnection();
        return;
    }
    if (pc.signalingState !== 'stable') {
        log('Cannot restart ICE: signalingState is ' + pc.signalingState + ', waiting for stable state');
        setTimeout(restartICE, 1000);
        return;
    }
    if (freezeCount >= maxFreezeRestarts) {
        log('Max ICE restarts reached, reconnecting fully');
        startConnection();
        return;
    }
    log('Restarting ICE to fix desync or freeze...');
    try {
        const offer = await pc.createOffer({ iceRestart: true });
        await pc.setLocalDescription(offer);
        log(`Restart ICE Offer SDP:\n${offer.sdp}`);
        const serverUrl = document.getElementById('serverUrl').value;
        const station = document.getElementById('station').value;
        const adsEnabled = document.getElementById('adsEnabled').checked;
        const response = await fetch(`${serverUrl}?station=${encodeURIComponent(station)}&adsEnabled=${adsEnabled}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(offer)
        });
        if (response.ok) {
            const answer = await response.json();
            log(`Remote Answer SDP:\n${answer.sdp}`);
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
            freezeCount++;
        } else {
            log(`Error restarting ICE: ${response.statusText}`);
            startConnection();
        }
    } catch (error) {
        log(`ICE restart failed: ${error}`);
        startConnection();
    }
}
</script>
</body>
</html>