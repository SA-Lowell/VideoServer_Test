<script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }
</script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Admin - Update Ad Break Points</title>
    <style>
        .video-player { width: 640px; height: 360px; }
        .breaks-list { margin-top: 20px; }
        .selected-breaks-list { margin-top: 20px; }
        .existing-breaks-list { margin-top: 20px; }
        .break-item { margin-bottom: 10px; }
        #folder-browser, #file-browser {
            border: 1px solid #ccc;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .dir-item, .file-item { cursor: pointer; margin-bottom: 5px; }
        .dir-item { color: blue; }
        .file-item { color: green; }
        #breadcrumb-nav { margin-top: 10px; }
        .breadcrumb-item {
            cursor: pointer;
            color: blue;
            text-decoration: underline;
            margin-right: 5px;
        }
        .breadcrumb-item:hover { color: darkblue; }
        .breadcrumb-item::after { content: '/'; margin-left: 5px; }
        .breadcrumb-item:last-child::after { content: ''; }
        .detector-buttons { margin-top: 10px; }
        .detection-status { margin-top: 10px; color: #333; font-weight: bold; display: none; }
        .detection-status.active { display: block; }
        .breaks-select { width: 300px; }
        .selected-breaks-list .break-item button { margin-left: 10px; }
        .existing-breaks-list .break-item button { margin-left: 10px; }
        .save-breaks-button { margin-top: 10px; }
        .seek-controls { margin-top: 10px; }
        .seek-seconds { width: 60px; }
        .video-section { margin-bottom: 20px; border: 1px solid #ccc; padding: 10px; display: none; }
        .video-section.active { display: block; }
        .pagination-controls { margin-bottom: 10px; }
        .pagination-controls button { margin-right: 10px; }
        .pagination-controls span { margin-right: 10px; }
        #selected-videos-container:empty + .pagination-controls { display: none; }
        .break-item .display-span { display: block; margin-bottom: 5px; }
        .break-item input[type="range"] { width: 300px; margin-right: 10px; }
        .break-item input[type="text"] { width: 120px; margin-right: 10px; }
        .fix-options { margin-left: 10px; }
        .fix-options label { margin-right: 10px; }
        .fade-params { margin-top: 10px; }
        .fade-params label { display: block; margin-bottom: 5px; }
    </style>
</head>
<body>
    <h1>Admin Panel - Update Ad Break Points</h1>
    <h2>Files from Video Folder</h2>
    <div id="current-path">Current Path: /</div>
    <div id="breadcrumb-nav"></div>
    <h3>Folders</h3>
    <div id="folder-browser"></div>
    <h3>Files in Current Folder</h3>
    <div id="file-browser"></div>
    <button onclick="navigateTo('')">Back to Root</button>
    <h2>Selected Videos</h2>
    <button id="clear-all-button">Clear All Selected Videos</button>
    <div class="pagination-controls">
        <button id="prev-button" disabled>Previous</button>
        <span id="pagination-info"></span>
        <button id="next-button" disabled>Next</button>
    </div>
    <div id="selected-videos-container"></div>
    <script>
        let videosData = {};
        let currentPath = '';
        let currentVideoIndex = -1;
        let videoIds = [];
        // Convert seconds to HH:MM:SS.dddd format
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            const formatted = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs.toFixed(4)).padStart(7, '0')}`;
            return formatted;
        }
        // Parse HH:MM:SS.dddd back to seconds
        function parseTime(timeStr) {
            const parts = timeStr.split(':');
            if (parts.length !== 3) return NaN;
            const hours = parseInt(parts[0], 10);
            const minutes = parseInt(parts[1], 10);
            const secs = parseFloat(parts[2]);
            if (isNaN(hours) || isNaN(minutes) || isNaN(secs)) return NaN;
            return hours * 3600 + minutes * 60 + secs;
        }
        function selectVideo(id, uri, metadataBreaks = []) {
            if (videosData[id]) {
                alert('Video already selected');
                return;
            }
            videosData[id] = {
                detectedBreaks: [],
                selectedBreaks: [],
                existingBreaks: metadataBreaks,
                uri: uri
            };
            videoIds.push(id);
            currentVideoIndex = videoIds.length - 1; // Set to the newly added video
            createSection(id, uri);
            updatePagination();
        }
        function createSection(id, uri) {
            const container = document.getElementById('selected-videos-container');
            const sectionHtml = `
                <div class="video-section" id="video-section-${id}">
                    <div>
                        Video ID: ${id}, URI: ${uri}
                        <button id="remove-button-${id}">Remove</button>
                        <span class="fix-options">
                            <label><input type="checkbox" id="remux-checkbox-${id}"> Remux</label>
                            <label><input type="checkbox" id="audio-checkbox-${id}"> Audio</label>
                            <label><input type="checkbox" id="video-checkbox-${id}"> Video</label>
                            <button id="fix-video-button-${id}">Fix Video</button>
                        </span>
                    </div>
                    <video class="video-player" id="video-player-${id}" controls></video>
                    <div class="seek-controls" id="seek-controls-${id}">
                        <input type="number" class="seek-seconds" id="seek-seconds-${id}" value="10" min="0"> seconds
                        <button id="seek-backward-button-${id}">Seek Backward</button>
                        <button id="seek-forward-button-${id}">Seek Forward</button>
                    </div>
                    <div class="detector-buttons">
                        <button id="detect-fade-button-${id}">Detect Fade-to-Black Ad Breaks</button>
                        <button id="detect-hard-cut-button-${id}">Detect Hard-Cut Ad Breaks</button>
                    </div>
                    <div class="detection-status" id="detection-status-${id}">Detecting ad breaks, please wait...</div>
                    <label>Preview left (secs): <input type="number" id="preview-left-${id}" value="10" min="0"></label>
                    <label> right: <input type="number" id="preview-right-${id}" value="10" min="0"></label>
                    <h3>Existing Break Points</h3>
                    <div class="existing-breaks-list" id="existing-breaks-list-${id}"></div>
                    <h3>Detected Breaks</h3>
                    <div class="breaks-list" id="breaks-list-${id}">
                        <select class="breaks-select" id="breaks-select-${id}" size="5"></select>
                        <button id="preview-break-button-${id}" disabled>Preview Selected Break</button>
                        <button id="add-break-button-${id}" disabled>Add Selected Break</button>
                    </div>
                    <div class="manual-add-break" style="margin-top: 10px;">
                        <h4>Add Manual Break</h4>
                        <label>Midpoint: <input type="text" id="manual-midpoint-${id}" placeholder="HH:MM:SS.dddd"></label>
                        <label>Span (secs): <input type="number" id="manual-span-${id}" value="3" min="0.1" step="0.1"></label>
                        <select id="manual-type-${id}">
                            <option value="hard">Hard</option>
                            <option value="fade">Fade</option>
                        </select>
                        <button id="add-manual-break-button-${id}">Add Manual Break</button>
                    </div>
                    <h3>Selected Breaks to Save</h3>
                    <div class="selected-breaks-list" id="selected-breaks-list-${id}"></div>
                    <button class="save-breaks-button" id="save-breaks-button-${id}" disabled>Save Breakpoints</button>
                    <div id="preview-container-${id}" style="display:none;">
                        <h3>Fade Preview</h3>
                        <video class="video-player" controls id="preview-video-${id}"></video>
                        <button id="close-preview-${id}">Close</button>
                    </div>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', sectionHtml);
            attachListeners(id);
            updateBreaksSelect(id);
            updateSelectedBreaksList(id);
            updateExistingBreaksList(id);
            const video = document.getElementById(`video-player-${id}`);
            video.src = `/videos/${uri}`;
            video.load();
        }
        function attachListeners(id) {
            document.getElementById(`detect-fade-button-${id}`).addEventListener('click', () => detectBreaks(id, 'fade'));
            document.getElementById(`detect-hard-cut-button-${id}`).addEventListener('click', () => detectBreaks(id, 'hard-cut'));
            document.getElementById(`add-break-button-${id}`).addEventListener('click', () => addSelectedBreak(id));
            document.getElementById(`preview-break-button-${id}`).addEventListener('click', () => previewSelectedBreak(id));
            document.getElementById(`save-breaks-button-${id}`).addEventListener('click', () => saveBreaks(id));
            document.getElementById(`seek-backward-button-${id}`).addEventListener('click', () => seekBackward(id));
            document.getElementById(`seek-forward-button-${id}`).addEventListener('click', () => seekForward(id));
            document.getElementById(`remove-button-${id}`).addEventListener('click', () => removeSection(id));
            document.getElementById(`fix-video-button-${id}`).addEventListener('click', () => fixVideo(id));
            document.getElementById(`close-preview-${id}`).addEventListener('click', () => document.getElementById(`preview-container-${id}`).style.display = 'none');
            document.getElementById(`add-manual-break-button-${id}`).addEventListener('click', () => addManualBreak(id));
        }
        function fixVideo(id) {
            const video = document.getElementById(`video-player-${id}`);
            const fixButton = document.getElementById(`fix-video-button-${id}`);
            const remuxCheckbox = document.getElementById(`remux-checkbox-${id}`);
            const audioCheckbox = document.getElementById(`audio-checkbox-${id}`);
            const videoCheckbox = document.getElementById(`video-checkbox-${id}`);
            if (!remuxCheckbox.checked && !audioCheckbox.checked && !videoCheckbox.checked) {
                alert('Please select at least one fix option (Remux, Audio, Video).');
                return;
            }
            fixButton.disabled = true;
            // Pause the video to release any file locks
            const wasPlaying = !video.paused;
            if (wasPlaying) {
                video.pause();
            }
            const body = {
                id: id,
                remux: remuxCheckbox.checked,
                audio: audioCheckbox.checked,
                video: videoCheckbox.checked
            };
            fetch('/fix-video', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            }).then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP error! Status: ${res.status}`);
                }
                return res.json();
            }).then(data => {
                if (data.temp_uri) {
                    const currentTime = video.currentTime;
                    video.src = `${data.temp_uri}?t=${new Date().getTime()}`; // Add timestamp to avoid caching
                    video.load();
                    video.addEventListener('loadeddata', () => {
                        video.currentTime = currentTime;
                        if (wasPlaying) {
                            video.play();
                        }
                    }, { once: true });
                    alert('Video fixed successfully (temporary version loaded)');
                } else {
                    throw new Error(data.error || 'Unknown error during video fix');
                }
                fixButton.disabled = false;
            }).catch(err => {
                fixButton.disabled = false;
                console.error('Error fixing video:', err);
                alert('Error fixing video: ' + err.message);
            });
        }
        function updatePagination() {
            const prevButton = document.getElementById('prev-button');
            const nextButton = document.getElementById('next-button');
            const paginationInfo = document.getElementById('pagination-info');
            if (videoIds.length === 0) {
                prevButton.disabled = true;
                nextButton.disabled = true;
                paginationInfo.textContent = '';
                currentVideoIndex = -1;
            } else {
                currentVideoIndex = Math.max(0, Math.min(currentVideoIndex, videoIds.length - 1));
                prevButton.disabled = currentVideoIndex <= 0;
                nextButton.disabled = currentVideoIndex >= videoIds.length - 1;
                paginationInfo.textContent = `Video ${currentVideoIndex + 1} of ${videoIds.length}`;
                showVideoSection(videoIds[currentVideoIndex]);
            }
        }
        function showVideoSection(id) {
            document.querySelectorAll('.video-section').forEach(section => {
                section.classList.remove('active');
            });
            const section = document.getElementById(`video-section-${id}`);
            if (section) {
                section.classList.add('active');
            }
        }
        function loadContents(path) {
            currentPath = path;
            document.getElementById('current-path').innerHTML = `Current Path: /${path}`;
            updateBreadcrumbNav();
            fetch(`/list-contents?path=${encodeURIComponent(path)}`)
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! Status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(data => {
                    console.log('Response data:', data);
                    if (!data.contents || !Array.isArray(data.contents)) {
                        throw new Error('Invalid response format: contents is missing or not an array');
                    }
                    const folderBrowser = document.getElementById('folder-browser');
                    const fileBrowser = document.getElementById('file-browser');
                    folderBrowser.innerHTML = '';
                    fileBrowser.innerHTML = '';
                    data.contents.forEach(item => {
                        const div = document.createElement('div');
                        if (item.type === 'dir') {
                            div.className = 'dir-item';
                            div.innerHTML = `/${item.name}/`;
                            div.onclick = () => navigateTo(item.path);
                            folderBrowser.appendChild(div);
                        } else {
                            div.className = 'file-item';
                            div.innerHTML = `${item.name}`;
                            div.onclick = () => {
                                fetch('/add-video', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ uri: item.path })
                                }).then(res => res.json()).then(addData => {
                                    fetchMetadata(addData.id, item.path);
                                }).catch(err => console.error(err));
                            };
                            fileBrowser.appendChild(div);
                        }
                    });
                })
                .catch(err => {
                    console.error('Error loading contents:', err);
                    document.getElementById('folder-browser').innerHTML = `<div style="color: red;">Error: ${err.message}</div>`;
                    document.getElementById('file-browser').innerHTML = `<div style="color: red;">Error: ${err.message}</div>`;
                });
        }
        function updateBreadcrumbNav() {
            const breadcrumbNav = document.getElementById('breadcrumb-nav');
            breadcrumbNav.innerHTML = '';
            const parts = currentPath.split('/').filter(part => part.length > 0);
            let cumulativePath = '';
            const rootSpan = document.createElement('span');
            rootSpan.className = 'breadcrumb-item';
            rootSpan.innerHTML = 'Root';
            rootSpan.onclick = () => navigateTo('');
            breadcrumbNav.appendChild(rootSpan);
            parts.forEach((part, index) => {
                cumulativePath += (index > 0 ? '/' : '') + part;
                const span = document.createElement('span');
                span.className = 'breadcrumb-item';
                span.innerHTML = part;
                const pathToNavigate = cumulativePath;
                span.onclick = () => navigateTo(pathToNavigate);
                breadcrumbNav.appendChild(span);
            });
        }
        function navigateTo(path) {
            loadContents(path);
        }
        function fetchMetadata(id, path) {
            fetch(`/get-video-metadata/${id}`)
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! Status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(data => {
                    const metadataBreaks = data.Metadata.filter(m => m.TypeName === 'break_point')
                        .map(m => {
                            let val = JSON.parse(m.Value);
                            let tim = typeof val === 'number' ? val : val.time;
                            if (isNaN(tim)) return null;
                            const start = Math.max(0, tim - 1);
                            const end = start + 2;
                            return {
                                value: val,
                                start,
                                end,
                                originalValue: JSON.parse(JSON.stringify(val)),
                                metaId: m.ID
                            };
                        })
                        .filter(b => b !== null)
                        .sort((a, b) => {
                            let at = typeof a.value === 'number' ? a.value : a.value.time;
                            let bt = typeof b.value === 'number' ? b.value : b.value.time;
                            return at - bt;
                        });
                    selectVideo(id, path, metadataBreaks);
                })
                .catch(err => {
                    console.error('Error fetching metadata:', err);
                    selectVideo(id, path, []);
                });
        }
        function detectBreaks(id, detectorType) {
            const statusDiv = document.getElementById(`detection-status-${id}`);
            const fadeButton = document.getElementById(`detect-fade-button-${id}`);
            const hardCutButton = document.getElementById(`detect-hard-cut-button-${id}`);
           
            statusDiv.classList.add('active');
            fadeButton.disabled = true;
            hardCutButton.disabled = true;
            const body = { id: id, detector: detectorType };
            fetch('/detect-breaks', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            }).then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP error! Status: ${res.status}`);
                }
                return res.json();
            }).then(data => {
                statusDiv.classList.remove('active');
                fadeButton.disabled = false;
                hardCutButton.disabled = false;
                videosData[id].detectedBreaks = data.breaks || [];
                updateBreaksSelect(id);
                const hasBreaks = videosData[id].detectedBreaks.length > 0;
                document.getElementById(`add-break-button-${id}`).disabled = !hasBreaks;
                document.getElementById(`preview-break-button-${id}`).disabled = !hasBreaks;
            }).catch(err => {
                statusDiv.classList.remove('active');
                fadeButton.disabled = false;
                hardCutButton.disabled = false;
                console.error(err);
                alert('Error detecting ad breaks: ' + err.message);
            });
        }
        function updateBreaksSelect(id) {
            const select = document.getElementById(`breaks-select-${id}`);
            select.innerHTML = '';
            videosData[id].detectedBreaks.forEach((b, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = `Start: ${formatTime(b.start)}, Mid: ${formatTime(b.mid)}, End: ${formatTime(b.end)}`;
                select.appendChild(option);
            });
        }
        function updateSelectedBreaksList(id) {
            const list = document.getElementById(`selected-breaks-list-${id}`);
            list.innerHTML = '';
            videosData[id].selectedBreaks.forEach((b, idx) => {
                const div = document.createElement('div');
                div.className = 'break-item';
                const displaySpan = document.createElement('span');
                displaySpan.className = 'display-span';
                const isHard = typeof b.value === 'number';
                if (isHard) {
                    displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(b.value)}, End: ${formatTime(b.end)}`;
                } else {
                    displaySpan.innerHTML = `Breakpoint: ${formatTime(b.value.time)}`;
                }
                div.appendChild(displaySpan);
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = b.start;
                slider.max = b.end;
                slider.step = 0.0001;
                slider.value = isHard ? b.value : b.value.time;
                slider.oninput = () => {
                    const newMid = parseFloat(slider.value);
                    const oldT = isHard ? b.value : b.value.time;
                    const delta = newMid - oldT;
                    if (isHard) {
                        b.value = newMid;
                    } else {
                        b.value.time = newMid;
                    }
                    b.start += delta;
                    b.end += delta;
                    timeInput.value = formatTime(newMid);
                    if (isHard) {
                        displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(newMid)}, End: ${formatTime(b.end)}`;
                    } else {
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(newMid)}`;
                    }
                };
                div.appendChild(slider);
                const timeInput = document.createElement('input');
                timeInput.type = 'text';
                timeInput.value = formatTime(isHard ? b.value : b.value.time);
                timeInput.size = 12;
                timeInput.onchange = () => {
                    const newTime = parseTime(timeInput.value);
                    const video = document.getElementById(`video-player-${id}`);
                    const dur = video.duration;
                    if (isNaN(newTime) || newTime < 0 || (!isNaN(dur) && newTime > dur)) {
                        alert('Invalid time or out of range');
                        timeInput.value = formatTime(isHard ? b.value : b.value.time);
                    } else {
                        const oldT = isHard ? b.value : b.value.time;
                        const left_offset = oldT - b.start;
                        const right_offset = b.end - oldT;
                        let new_start = newTime - left_offset;
                        let new_end = newTime + right_offset;
                        new_start = Math.max(0, new_start);
                        if (!isNaN(dur)) {
                            new_end = Math.min(dur, new_end);
                        }
                        b.start = new_start;
                        b.end = new_end;
                        if (isHard) {
                            b.value = newTime;
                        } else {
                            b.value.time = newTime;
                        }
                        slider.min = b.start;
                        slider.max = b.end;
                        slider.value = newTime;
                        timeInput.value = formatTime(newTime);
                        if (isHard) {
                            displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(newTime)}, End: ${formatTime(b.end)}`;
                        } else {
                            displaySpan.innerHTML = `Breakpoint: ${formatTime(newTime)}`;
                        }
                    }
                };
                div.appendChild(timeInput);
                const typeLabel = document.createElement('label');
                typeLabel.innerText = 'Type: ';
                div.appendChild(typeLabel);
                const typeSelect = document.createElement('select');
                typeSelect.innerHTML = `<option value="hard">Hard</option><option value="fade">Fade</option>`;
                typeSelect.value = isHard ? 'hard' : 'fade';
                div.appendChild(typeSelect);
                typeSelect.onchange = (e) => {
                    const nt = e.target.value;
                    if (nt === 'hard' && !isHard) {
                        b.value = b.value.time;
                    } else if (nt === 'fade' && isHard) {
                        const oldTime = b.value;
                        b.value = {
                            type: 'fade',
                            time: oldTime,
                            color: '#000000',
                            fade_out: {
                                video: {start: -1, end: 0},
                                audio: {start: -1, end: 0}
                            },
                            fade_in: {
                                video: {start: 0, end: 1},
                                audio: {start: 0, end: 1}
                            }
                        };
                    }
                    updateSelectedBreaksList(id);
                };
                if (isHard) {
                    const stepBackwardBtn = document.createElement('button');
                    stepBackwardBtn.textContent = 'Step Backward';
                    stepBackwardBtn.onclick = () => {
                        const breakPoint = videosData[id].selectedBreaks[idx];
                        const duration = breakPoint.end - breakPoint.start;
                        let newEnd = breakPoint.start;
                        let newStart = newEnd - duration;
                        if (newStart < 0) {
                            newStart = 0;
                            newEnd = duration;
                        }
                        breakPoint.start = newStart;
                        breakPoint.end = newEnd;
                        breakPoint.value = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value;
                        timeInput.value = formatTime(breakPoint.value);
                        displaySpan.innerHTML = `Start: ${formatTime(breakPoint.start)}, Mid: ${formatTime(breakPoint.value)}, End: ${formatTime(breakPoint.end)}`;
                    };
                    div.appendChild(stepBackwardBtn);
                    const stepForwardBtn = document.createElement('button');
                    stepForwardBtn.textContent = 'Step Forward';
                    stepForwardBtn.onclick = () => {
                        const breakPoint = videosData[id].selectedBreaks[idx];
                        const duration = breakPoint.end - breakPoint.start;
                        let newStart = breakPoint.end;
                        let newEnd = newStart + duration;
                        breakPoint.start = newStart;
                        breakPoint.end = newEnd;
                        breakPoint.value = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value;
                        timeInput.value = formatTime(breakPoint.value);
                        displaySpan.innerHTML = `Start: ${formatTime(breakPoint.start)}, Mid: ${formatTime(breakPoint.value)}, End: ${formatTime(breakPoint.end)}`;
                    };
                    div.appendChild(stepForwardBtn);
                }
                if (!isHard) {
                    const shiftBackwardBtn = document.createElement('button');
                    shiftBackwardBtn.textContent = 'Shift -1s';
                    shiftBackwardBtn.onclick = () => {
                        const breakPoint = videosData[id].selectedBreaks[idx];
                        const rangeDuration = breakPoint.end - breakPoint.start;
                        breakPoint.start = Math.max(0, breakPoint.start - 1);
                        breakPoint.end = breakPoint.start + rangeDuration;
                        breakPoint.value.time = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value.time));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value.time;
                        timeInput.value = formatTime(breakPoint.value.time);
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(breakPoint.value.time)}`;
                    };
                    div.appendChild(shiftBackwardBtn);

                    const shiftForwardBtn = document.createElement('button');
                    shiftForwardBtn.textContent = 'Shift +1s';
                    shiftForwardBtn.onclick = () => {
                        const breakPoint = videosData[id].selectedBreaks[idx];
                        const rangeDuration = breakPoint.end - breakPoint.start;
                        breakPoint.start += 1;
                        breakPoint.end = breakPoint.start + rangeDuration;
                        breakPoint.value.time = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value.time));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value.time;
                        timeInput.value = formatTime(breakPoint.value.time);
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(breakPoint.value.time)}`;
                    };
                    div.appendChild(shiftForwardBtn);
                }
                const resetBtn = document.createElement('button');
                resetBtn.textContent = 'Reset Time';
                resetBtn.onclick = () => {
                    b.value = JSON.parse(JSON.stringify(b.originalValue));
                    const midTime = typeof b.value === 'number' ? b.value : b.value.time;
                    slider.value = midTime;
                    timeInput.value = formatTime(midTime);
                    if (typeof b.value === 'number') {
                        displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(midTime)}, End: ${formatTime(b.end)}`;
                    } else {
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(midTime)}`;
                    }
                    updateSelectedBreaksList(id);
                };
                div.appendChild(resetBtn);
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = () => {
                    videosData[id].selectedBreaks.splice(idx, 1);
                    updateSelectedBreaksList(id);
                    document.getElementById(`save-breaks-button-${id}`).disabled = videosData[id].selectedBreaks.length === 0;
                };
                div.appendChild(removeBtn);
                const previewBtn = document.createElement('button');
                previewBtn.textContent = 'Preview Jump';
                previewBtn.onclick = () => previewBreak(id, typeof b.value === 'number' ? b.value : b.value.time);
                div.appendChild(previewBtn);
                if (!isHard) {
                    const fadePreviewBtn = document.createElement('button');
                    fadePreviewBtn.textContent = 'Preview Fade';
                    fadePreviewBtn.onclick = () => previewFade(id, idx, false);
                    div.appendChild(fadePreviewBtn);
                    const fadeParamsDiv = document.createElement('div');
                    fadeParamsDiv.className = 'fade-params';
                    const addFadeInput = (parent, labelText, obj, key) => {
                        const label = document.createElement('label');
                        label.innerText = `${labelText} (rel): `;
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.step = '0.001';
                        input.value = obj[key].toFixed(4);
                        input.onchange = () => {
                            const newRel = parseFloat(input.value);
                            if (!isNaN(newRel)) {
                                obj[key] = newRel;
                                input.value = newRel.toFixed(4);
                            } else {
                                input.value = obj[key].toFixed(4);
                            }
                        };
                        label.appendChild(input);
                        parent.appendChild(label);
                    };
                    const colorLabel = document.createElement('label');
                    colorLabel.innerText = 'Color: ';
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = b.value.color;
                    colorInput.onchange = () => { b.value.color = colorInput.value; };
                    colorLabel.appendChild(colorInput);
                    fadeParamsDiv.appendChild(colorLabel);
                    addFadeInput(fadeParamsDiv, 'Fade Out Video Start', b.value.fade_out.video, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade Out Video End', b.value.fade_out.video, 'end');
                    addFadeInput(fadeParamsDiv, 'Fade Out Audio Start', b.value.fade_out.audio, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade Out Audio End', b.value.fade_out.audio, 'end');
                    addFadeInput(fadeParamsDiv, 'Fade In Video Start', b.value.fade_in.video, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade In Video End', b.value.fade_in.video, 'end');
                    addFadeInput(fadeParamsDiv, 'Fade In Audio Start', b.value.fade_in.audio, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade In Audio End', b.value.fade_in.audio, 'end');
                    div.appendChild(fadeParamsDiv);
                }
                list.appendChild(div);
            });
        }
        function updateExistingBreaksList(id) {
            const list = document.getElementById(`existing-breaks-list-${id}`);
            list.innerHTML = '';
            videosData[id].existingBreaks.forEach((b, idx) => {
                const div = document.createElement('div');
                div.className = 'break-item';
                const displaySpan = document.createElement('span');
                displaySpan.className = 'display-span';
                const isHard = typeof b.value === 'number';
                if (isHard) {
                    displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(b.value)}, End: ${formatTime(b.end)}`;
                } else {
                    displaySpan.innerHTML = `Breakpoint: ${formatTime(b.value.time)}`;
                }
                div.appendChild(displaySpan);
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = b.start;
                slider.max = b.end;
                slider.step = 0.0001;
                slider.value = isHard ? b.value : b.value.time;
                slider.oninput = () => {
                    const newMid = parseFloat(slider.value);
                    const oldT = isHard ? b.value : b.value.time;
                    const delta = newMid - oldT;
                    if (isHard) {
                        b.value = newMid;
                    } else {
                        b.value.time = newMid;
                    }
                    b.start += delta;
                    b.end += delta;
                    timeInput.value = formatTime(newMid);
                    if (isHard) {
                        displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(newMid)}, End: ${formatTime(b.end)}`;
                    } else {
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(newMid)}`;
                    }
                };
                div.appendChild(slider);
                const timeInput = document.createElement('input');
                timeInput.type = 'text';
                timeInput.value = formatTime(isHard ? b.value : b.value.time);
                timeInput.size = 12;
                timeInput.onchange = () => {
                    const newTime = parseTime(timeInput.value);
                    const video = document.getElementById(`video-player-${id}`);
                    const dur = video.duration;
                    if (isNaN(newTime) || newTime < 0 || (!isNaN(dur) && newTime > dur)) {
                        alert('Invalid time or out of range');
                        timeInput.value = formatTime(isHard ? b.value : b.value.time);
                    } else {
                        const oldT = isHard ? b.value : b.value.time;
                        const left_offset = oldT - b.start;
                        const right_offset = b.end - oldT;
                        let new_start = newTime - left_offset;
                        let new_end = newTime + right_offset;
                        new_start = Math.max(0, new_start);
                        if (!isNaN(dur)) {
                            new_end = Math.min(dur, new_end);
                        }
                        b.start = new_start;
                        b.end = new_end;
                        if (isHard) {
                            b.value = newTime;
                        } else {
                            b.value.time = newTime;
                        }
                        slider.min = b.start;
                        slider.max = b.end;
                        slider.value = newTime;
                        timeInput.value = formatTime(newTime);
                        if (isHard) {
                            displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(newTime)}, End: ${formatTime(b.end)}`;
                        } else {
                            displaySpan.innerHTML = `Breakpoint: ${formatTime(newTime)}`;
                        }
                    }
                };
                div.appendChild(timeInput);
                const typeLabel = document.createElement('label');
                typeLabel.innerText = 'Type: ';
                div.appendChild(typeLabel);
                const typeSelect = document.createElement('select');
                typeSelect.innerHTML = `<option value="hard">Hard</option><option value="fade">Fade</option>`;
                typeSelect.value = isHard ? 'hard' : 'fade';
                div.appendChild(typeSelect);
                typeSelect.onchange = (e) => {
                    const nt = e.target.value;
                    if (nt === 'hard' && !isHard) {
                        b.value = b.value.time;
                    } else if (nt === 'fade' && isHard) {
                        const oldTime = b.value;
                        b.value = {
                            type: 'fade',
                            time: oldTime,
                            color: '#000000',
                            fade_out: {
                                video: {start: -1, end: 0},
                                audio: {start: -1, end: 0}
                            },
                            fade_in: {
                                video: {start: 0, end: 1},
                                audio: {start: 0, end: 1}
                            }
                        };
                    }
                    updateExistingBreaksList(id);
                };
                if (isHard) {
                    const shiftBackwardBtn = document.createElement('button');
                    shiftBackwardBtn.textContent = 'Shift -1s';
                    shiftBackwardBtn.onclick = () => {
                        const breakPoint = videosData[id].existingBreaks[idx];
                        const rangeDuration = breakPoint.end - breakPoint.start;
                        breakPoint.start = Math.max(0, breakPoint.start - 1);
                        breakPoint.end = breakPoint.start + rangeDuration;
                        breakPoint.value = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value;
                        timeInput.value = formatTime(breakPoint.value);
                        displaySpan.innerHTML = `Start: ${formatTime(breakPoint.start)}, Mid: ${formatTime(breakPoint.value)}, End: ${formatTime(breakPoint.end)}`;
                    };
                    div.appendChild(shiftBackwardBtn);
                    const shiftForwardBtn = document.createElement('button');
                    shiftForwardBtn.textContent = 'Shift +1s';
                    shiftForwardBtn.onclick = () => {
                        const breakPoint = videosData[id].existingBreaks[idx];
                        const rangeDuration = breakPoint.end - breakPoint.start;
                        breakPoint.start += 1;
                        breakPoint.end = breakPoint.start + rangeDuration;
                        breakPoint.value = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value;
                        timeInput.value = formatTime(breakPoint.value);
                        displaySpan.innerHTML = `Start: ${formatTime(breakPoint.start)}, Mid: ${formatTime(breakPoint.value)}, End: ${formatTime(breakPoint.end)}`;
                    };
                    div.appendChild(shiftForwardBtn);
                }
                if (!isHard) {
                    const shiftBackwardBtn = document.createElement('button');
                    shiftBackwardBtn.textContent = 'Shift -1s';
                    shiftBackwardBtn.onclick = () => {
                        const breakPoint = videosData[id].existingBreaks[idx];
                        const rangeDuration = breakPoint.end - breakPoint.start;
                        breakPoint.start = Math.max(0, breakPoint.start - 1);
                        breakPoint.end = breakPoint.start + rangeDuration;
                        breakPoint.value.time = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value.time));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value.time;
                        timeInput.value = formatTime(breakPoint.value.time);
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(breakPoint.value.time)}`;
                    };
                    div.appendChild(shiftBackwardBtn);
                    const shiftForwardBtn = document.createElement('button');
                    shiftForwardBtn.textContent = 'Shift +1s';
                    shiftForwardBtn.onclick = () => {
                        const breakPoint = videosData[id].existingBreaks[idx];
                        const rangeDuration = breakPoint.end - breakPoint.start;
                        breakPoint.start += 1;
                        breakPoint.end = breakPoint.start + rangeDuration;
                        breakPoint.value.time = Math.min(breakPoint.end, Math.max(breakPoint.start, breakPoint.value.time));
                        slider.min = breakPoint.start;
                        slider.max = breakPoint.end;
                        slider.value = breakPoint.value.time;
                        timeInput.value = formatTime(breakPoint.value.time);
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(breakPoint.value.time)}`;
                    };
                    div.appendChild(shiftForwardBtn);
                }
                const resetBtn = document.createElement('button');
                resetBtn.textContent = 'Reset Time';
                resetBtn.onclick = () => {
                    b.value = JSON.parse(JSON.stringify(b.originalValue));
                    const midTime = typeof b.value === 'number' ? b.value : b.value.time;
                    slider.value = midTime;
                    timeInput.value = formatTime(midTime);
                    if (typeof b.value === 'number') {
                        displaySpan.innerHTML = `Start: ${formatTime(b.start)}, Mid: ${formatTime(midTime)}, End: ${formatTime(b.end)}`;
                    } else {
                        displaySpan.innerHTML = `Breakpoint: ${formatTime(midTime)}`;
                    }
                    updateExistingBreaksList(id);
                };
                div.appendChild(resetBtn);
                const updateBtn = document.createElement('button');
                updateBtn.textContent = 'Update';
                updateBtn.onclick = () => updateExistingBreak(id, idx);
                div.appendChild(updateBtn);
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = () => deleteExistingBreak(id, idx);
                div.appendChild(removeBtn);
                const previewBtn = document.createElement('button');
                previewBtn.textContent = 'Preview Jump';
                previewBtn.onclick = () => previewBreak(id, typeof b.value === 'number' ? b.value : b.value.time);
                div.appendChild(previewBtn);
                if (!isHard) {
                    const fadePreviewBtn = document.createElement('button');
                    fadePreviewBtn.textContent = 'Preview Fade';
                    fadePreviewBtn.onclick = () => previewFade(id, idx, true);
                    div.appendChild(fadePreviewBtn);
                    const fadeParamsDiv = document.createElement('div');
                    fadeParamsDiv.className = 'fade-params';
                    const addFadeInput = (parent, labelText, obj, key) => {
                        const label = document.createElement('label');
                        label.innerText = `${labelText} (rel): `;
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.step = '0.001';
                        input.value = obj[key].toFixed(4);
                        input.onchange = () => {
                            const newRel = parseFloat(input.value);
                            if (!isNaN(newRel)) {
                                obj[key] = newRel;
                                input.value = newRel.toFixed(4);
                            } else {
                                input.value = obj[key].toFixed(4);
                            }
                        };
                        label.appendChild(input);
                        parent.appendChild(label);
                    };
                    const colorLabel = document.createElement('label');
                    colorLabel.innerText = 'Color: ';
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = b.value.color;
                    colorInput.onchange = () => { b.value.color = colorInput.value; };
                    colorLabel.appendChild(colorInput);
                    fadeParamsDiv.appendChild(colorLabel);
                    addFadeInput(fadeParamsDiv, 'Fade Out Video Start', b.value.fade_out.video, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade Out Video End', b.value.fade_out.video, 'end');
                    addFadeInput(fadeParamsDiv, 'Fade Out Audio Start', b.value.fade_out.audio, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade Out Audio End', b.value.fade_out.audio, 'end');
                    addFadeInput(fadeParamsDiv, 'Fade In Video Start', b.value.fade_in.video, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade In Video End', b.value.fade_in.video, 'end');
                    addFadeInput(fadeParamsDiv, 'Fade In Audio Start', b.value.fade_in.audio, 'start');
                    addFadeInput(fadeParamsDiv, 'Fade In Audio End', b.value.fade_in.audio, 'end');
                    div.appendChild(fadeParamsDiv);
                }
                list.appendChild(div);
            });
        }
        function updateExistingBreak(id, idx) {
            const breakPoint = videosData[id].existingBreaks[idx];
            const data = { id: breakPoint.metaId, value: breakPoint.value };
            fetch('/update-break', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            }).then(res => res.json()).then(resp => {
                if (resp.success) {
                    alert('Breakpoint updated successfully');
                    breakPoint.originalValue = JSON.parse(JSON.stringify(breakPoint.value));
                }
            }).catch(err => {
                alert('Error updating breakpoint: ' + err.message);
            });
        }
        function deleteExistingBreak(id, idx) {
            const metaId = videosData[id].existingBreaks[idx].metaId;
            fetch('/delete-break', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: metaId })
            }).then(res => res.json()).then(resp => {
                if (resp.success) {
                    videosData[id].existingBreaks.splice(idx, 1);
                    updateExistingBreaksList(id);
                }
            }).catch(err => {
                alert('Error deleting breakpoint: ' + err.message);
            });
        }
        function addSelectedBreak(id) {
            const select = document.getElementById(`breaks-select-${id}`);
            const selectedIndex = select.selectedIndex;
            if (selectedIndex >= 0) {
                const breakPoint = videosData[id].detectedBreaks[selectedIndex];
                if (!videosData[id].selectedBreaks.some(b => {
                    let bt = typeof b.value === 'number' ? b.value : b.value.time;
                    return bt === breakPoint.mid;
                })) {
                    videosData[id].selectedBreaks.push({
                        value: breakPoint.mid,
                        start: breakPoint.start,
                        end: breakPoint.end,
                        originalValue: breakPoint.mid
                    });
                    updateSelectedBreaksList(id);
                    document.getElementById(`save-breaks-button-${id}`).disabled = false;
                }
            }
        }
        function previewSelectedBreak(id) {
            const select = document.getElementById(`breaks-select-${id}`);
            const selectedIndex = select.selectedIndex;
            if (selectedIndex >= 0) {
                const breakPoint = videosData[id].detectedBreaks[selectedIndex];
                previewBreak(id, breakPoint.mid);
            }
        }
        function saveBreaks(id) {
            if (videosData[id].selectedBreaks.length === 0) return;
            const breaks = videosData[id].selectedBreaks.map(b => ({ id: id, value: b.value }));
            fetch('/add-breaks', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(breaks)
            }).then(res => res.json()).then(data => {
                if (data.success) {
                    alert('Breakpoints saved successfully');
                    fetchMetadataForUpdate(id);
                }
            }).catch(err => {
                console.error(err);
                alert('Error saving breakpoints: ' + err.message);
            });
        }
        function fetchMetadataForUpdate(id) {
            fetch(`/get-video-metadata/${id}`)
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! Status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(data => {
                    const metadataBreaks = data.Metadata.filter(m => m.TypeName === 'break_point')
                        .map(m => {
                            let val = JSON.parse(m.Value);
                            let tim = typeof val === 'number' ? val : val.time;
                            if (isNaN(tim)) return null;
                            const start = Math.max(0, tim - 1);
                            const end = start + 2;
                            return {
                                value: val,
                                start,
                                end,
                                originalValue: JSON.parse(JSON.stringify(val)),
                                metaId: m.ID
                            };
                        })
                        .filter(b => b !== null)
                        .sort((a, b) => {
                            let at = typeof a.value === 'number' ? a.value : a.value.time;
                            let bt = typeof b.value === 'number' ? b.value : b.value.time;
                            return at - bt;
                        });
                    videosData[id].existingBreaks = metadataBreaks;
                    videosData[id].selectedBreaks = [];
                    updateSelectedBreaksList(id);
                    updateExistingBreaksList(id);
                    document.getElementById(`save-breaks-button-${id}`).disabled = true;
                })
                .catch(err => {
                    console.error('Error refreshing metadata:', err);
                });
        }
        function seekBackward(id) {
            const video = document.getElementById(`video-player-${id}`);
            if (isNaN(video.duration)) {
                alert('Video not loaded yet. Please wait.');
                return;
            }
            const seconds = parseFloat(document.getElementById(`seek-seconds-${id}`).value) || 0;
            video.currentTime = Math.max(0, video.currentTime - seconds);
        }
        function seekForward(id) {
            const video = document.getElementById(`video-player-${id}`);
            if (isNaN(video.duration)) {
                alert('Video not loaded yet. Please wait.');
                return;
            }
            const seconds = parseFloat(document.getElementById(`seek-seconds-${id}`).value) || 0;
            video.currentTime = Math.min(video.duration, video.currentTime + seconds);
        }
        function previewBreak(id, time) {
            const video = document.getElementById(`video-player-${id}`);
            if (isNaN(video.duration)) {
                alert('Video not loaded yet. Please wait.');
                return;
            }
            video.currentTime = time;
            video.play();
        }
        function previewFade(id, idx, isExisting) {
            const list = isExisting ? videosData[id].existingBreaks : videosData[id].selectedBreaks;
            const bp = list[idx];
            const left = parseFloat(document.getElementById(`preview-left-${id}`).value) || 10;
            const right = parseFloat(document.getElementById(`preview-right-${id}`).value) || 10;
            const body = { id: id, value: bp.value, left: left, right: right };
            fetch('/preview-fade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            }).then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP error! Status: ${res.status}`);
                }
                return res.json();
            }).then(data => {
                if (data.temp_uri) {
                    const cont = document.getElementById(`preview-container-${id}`);
                    cont.style.display = 'block';
                    const vid = document.getElementById(`preview-video-${id}`);
                    vid.src = `${data.temp_uri}?t=${new Date().getTime()}`;
                    vid.load();
                    vid.play();
                }
            }).catch(err => {
                console.error(err);
                alert('Error generating fade preview: ' + err.message);
            });
        }
        function removeSection(id) {
            document.getElementById(`video-section-${id}`).remove();
            delete videosData[id];
            const removedIndex = videoIds.indexOf(id);
            videoIds = videoIds.filter(vid => vid !== id);
            if (videoIds.length === 0) {
                currentVideoIndex = -1;
            } else {
                if (removedIndex === currentVideoIndex) {
                    if (currentVideoIndex >= videoIds.length) {
                        currentVideoIndex = videoIds.length - 1;
                    }
                } else if (removedIndex < currentVideoIndex) {
                    currentVideoIndex = Math.max(0, currentVideoIndex - 1);
                }
            }
            updatePagination();
        }

        function addManualBreak(id) {
            const midpointInput = document.getElementById(`manual-midpoint-${id}`);
            const spanInput = document.getElementById(`manual-span-${id}`);
            const typeSelect = document.getElementById(`manual-type-${id}`);
            const video = document.getElementById(`video-player-${id}`);

            let midStr = midpointInput.value.trim();
            const span = parseFloat(spanInput.value) || 3;
            const type = typeSelect.value;

            let mid = parseTime(midStr);
            if (midStr === '') {
                mid = video.currentTime;
                midpointInput.value = formatTime(mid);
            }
            if (isNaN(mid) || mid < 0) {
                alert('Invalid midpoint time. Use HH:MM:SS.dddd format.');
                return;
            }
            if (span <= 0) {
                alert('Span must be positive.');
                return;
            }

            const halfSpan = span / 2;
            const start = Math.max(0, mid - halfSpan);
            const end = mid + halfSpan;

            let value;
            let originalValue;
            if (type === 'hard') {
                value = mid;
                originalValue = mid;
            } else { // fade
                value = {
                    type: 'fade',
                    time: mid,
                    color: '#000000',
                    fade_out: {
                        video: {start: -1, end: 0},
                        audio: {start: -1, end: 0}
                    },
                    fade_in: {
                        video: {start: 0, end: 1},
                        audio: {start: 0, end: 1}
                    }
                };
                originalValue = JSON.parse(JSON.stringify(value));
            }

            if (videosData[id].selectedBreaks.some(b => {
                let bt = typeof b.value === 'number' ? b.value : b.value.time;
                return bt === mid;
            })) {
                alert('Break at this time already exists.');
                return;
            }

            videosData[id].selectedBreaks.push({
                value,
                start,
                end,
                originalValue
            });

            videosData[id].selectedBreaks.sort((a, b) => {
                let at = typeof a.value === 'number' ? a.value : a.value.time;
                let bt = typeof b.value === 'number' ? b.value : b.value.time;
                return at - bt;
            });

            updateSelectedBreaksList(id);
            document.getElementById(`save-breaks-button-${id}`).disabled = false;

            midpointInput.value = '';
            spanInput.value = '3';
            typeSelect.value = 'hard';
        }

        document.getElementById('clear-all-button').addEventListener('click', () => {
            document.getElementById('selected-videos-container').innerHTML = '';
            videosData = {};
            videoIds = [];
            currentVideoIndex = -1;
            updatePagination();
        });
        document.getElementById('prev-button').addEventListener('click', () => {
            if (currentVideoIndex > 0) {
                currentVideoIndex--;
                updatePagination();
            }
        });
        document.getElementById('next-button').addEventListener('click', () => {
            if (currentVideoIndex < videoIds.length - 1) {
                currentVideoIndex++;
                updatePagination();
            }
        });
        loadContents('');
    </script>
</body>
</html>