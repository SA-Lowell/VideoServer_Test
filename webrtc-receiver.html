<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Video Receiver</title>
    <style>
        #videoContainer {
            position: relative;
            width: 640px;
            height: 480px;
            background-color: black;
        }
        video {
            width: 100%;
            height: 100%;
        }
        #staticCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: none;
        }
    </style>
</head>
<body>
    <h1>WebRTC Video Receiver</h1>
    <div id="videoContainer">
        <video id="remoteVideo" autoplay playsinline controls></video>
        <canvas id="staticCanvas" width="640" height="480"></canvas>
    </div>
    <button id="startButton">Start Connection</button>
    <label for="serverUrl">Go Server URL (e.g., http://192.168.0.60:8081/signal):</label>
    <input id="serverUrl" type="text" value="http://192.168.0.60:8081/signal" style="width: 300px;">
    <label for="station">Station (e.g., channel1, channel2, channel3):</label>
    <input id="station" type="text" value="channel1" style="width: 150px;">
    <button id="sendOfferButton" disabled>Send Offer to Server</button>
    <button id="restartIceButton" disabled>Restart ICE</button>
    <pre id="log"></pre>

    <script>
        // Utility to log messages to the console and the page
        function log(message) {
            console.log(message);
            const logElement = document.getElementById('log');
            logElement.textContent += message + '\n';
        }

        // Configuration for ICE servers
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
            ]
        };

        // Variables
        let pc = null;
        let remoteStream = null;
        let offer = null;
        let candidates = [];

        // Static effect variables
        const staticCanvas = document.getElementById('staticCanvas');
        const staticCtx = staticCanvas.getContext('2d');
        let staticInterval;
        let staticTime = 0;

        // Audio variables for static noise
        let audioCtx;
        let noiseNode;
        let gainNode;

        function startStatic() {
            staticCanvas.style.display = 'block';
            staticInterval = setInterval(makeStaticNoise, 50);
            log('Starting TV static effect');

            // Start audio
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            noiseNode = audioCtx.createScriptProcessor(4096, 1, 1);
            noiseNode.onaudioprocess = function(e) {
                const output = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = Math.random() * 2 - 1; // White noise
                }
            };
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.05; // Lower volume to avoid being too loud
            noiseNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            log('Starting static audio');
        }

        function stopStatic() {
            clearInterval(staticInterval);
            staticCanvas.style.display = 'none';
            log('Stopping TV static effect');

            // Stop audio with fade out
            if (audioCtx && gainNode) {
                try {
                    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5); // Fade to 0 over 0.5 seconds
                } catch (error) {
                    log('Error during audio fade: ' + error);
                }
                setTimeout(() => {
                    if (noiseNode) noiseNode.disconnect();
                    if (gainNode) gainNode.disconnect();
                    if (audioCtx) {
                        audioCtx.close().then(() => {
                            log('AudioContext closed');
                        }).catch(error => {
                            log('Error closing AudioContext: ' + error);
                        });
                        audioCtx = null;
                    }
                    log('Stopping static audio');
                }, 500);
            }
        }

        function makeStaticNoise() {
            const width = staticCanvas.width;
            const height = staticCanvas.height;
            const imgd = staticCtx.createImageData(width, height);
            const pix = imgd.data;

            for (let i = 0, n = pix.length; i < n; i += 4) {
                const c = 7 + Math.sin(i / 50000 + staticTime / 7);
                const gray = 40 * Math.random() * c;
                pix[i] = pix[i + 1] = pix[i + 2] = gray;
                pix[i + 3] = 255; // alpha
            }

            staticCtx.putImageData(imgd, 0, 0);
            staticTime = (staticTime + 1) % height;
        }

        // Function to create the local offer (recvonly video and audio)
        async function createOffer() {
            pc = new RTCPeerConnection(configuration);

            // Event listeners for debugging
            pc.oniceconnectionstatechange = () => {
                log('ICE connection state: ' + pc.iceConnectionState);
                if (pc.iceConnectionState === 'disconnected') {
                    stopStatic();
                    log('ICE disconnected - attempting automatic restart in 5 seconds...');
                    setTimeout(restartIce, 5000);
                }
                if (pc.iceConnectionState === 'failed') {
                    stopStatic();
                    log('ICE failed - manual restart may be needed.');
                    document.getElementById('restartIceButton').disabled = false;
                }
                if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                    const videoElement = document.getElementById('remoteVideo');
                    videoElement.srcObject = remoteStream;
                    log('ICE connected - assigned stream to video element.');
                }
            };

            pc.onconnectionstatechange = () => {
                log('Peer connection state: ' + pc.connectionState);
            };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    log('New ICE candidate: ' + JSON.stringify(event.candidate));
                    candidates.push(event.candidate);
                } else {
                    log('All ICE candidates gathered (end-of-candidates)');
                }
            };

            pc.ontrack = (event) => {
                log('Track received: ' + event.track.kind + ' ' + event.track.readyState);
                if (!remoteStream) {
                    remoteStream = new MediaStream();
                }
                remoteStream.addTrack(event.track);
                event.track.onmute = () => log('Track muted - possible black screen or no media flow');
                event.track.onunmute = () => log('Track unmuted - media flowing');
            };

            // Create offer
            offer = await pc.createOffer({
                offerToReceiveVideo: true,
                offerToReceiveAudio: true
            });
            await pc.setLocalDescription(offer);
            log('Local Offer SDP: ' + offer.sdp);
        }

        // Function to send offer to Go server via fetch
        async function sendOfferToServer() {
            stopStatic(); // Stop any existing static first to prevent multiples/orphans
            startStatic(); // Then start new static

            if (pc) {
                pc.close();
                pc = null;
                offer = null;
                candidates = [];
                if (remoteStream) {
                    remoteStream.getTracks().forEach(track => track.stop());
                    remoteStream = null;
                }
                document.getElementById('remoteVideo').srcObject = null;
                document.getElementById('restartIceButton').disabled = true;
                log('Closed existing connection to switch channels');
            }

            await createOffer();

            const serverUrlInput = document.getElementById('serverUrl').value;
            const station = document.getElementById('station').value;
            let serverUrl = serverUrlInput;
            if (station && station !== 'default') {
                const separator = serverUrlInput.includes('?') ? '&' : '?';
                serverUrl += separator + 'station=' + encodeURIComponent(station);
            }

            try {
                const response = await fetch(serverUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sdp: offer.sdp, type: offer.type })
                });
                if (!response.ok) {
                    throw new Error('HTTP error: ' + response.status);
                }
                const answerJson = await response.json();
                const answer = new RTCSessionDescription(answerJson);
                await pc.setRemoteDescription(answer);
                log('Remote Answer SDP set: ' + answer.sdp);
                document.getElementById('restartIceButton').disabled = false;
            } catch (error) {
                log('Error sending offer: ' + error);
                stopStatic();
            }
        }

        // Function for ICE restart
        async function restartIce() {
            log('Restarting connection...');
            await sendOfferToServer();
        }

        // Periodically get stats for debugging
        function startStatsLogging() {
            setInterval(async () => {
                if (!pc) return;
                try {
                    const stats = await pc.getStats();
                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'video') {
                            log('Video inbound: packetsReceived=' + (report.packetsReceived || 0) + ', bytesReceived=' + (report.bytesReceived || 0) + ', packetsLost=' + (report.packetsLost || 0) + ', jitter=' + (report.jitter || 0) + ', frameRate=' + (report.frameRate || 0));
                        }
                        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                            log('Audio inbound: packetsReceived=' + (report.packetsReceived || 0) + ', bytesReceived=' + (report.bytesReceived || 0) + ', packetsLost=' + (report.packetsLost || 0) + ', jitter=' + (report.jitter || 0));
                        }
                        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                            log('Active candidate pair: localType=' + report.localCandidateId + ', remoteType=' + report.remoteCandidateId + ', bytesSent=' + report.bytesSent + ', bytesReceived=' + report.bytesReceived);
                        }
                    });
                } catch (error) {
                    log('getStats error: ' + error);
                }
            }, 5000);
        }

        // Setup video playing event to stop static
        const videoElement = document.getElementById('remoteVideo');
        videoElement.onplaying = () => {
            stopStatic();
            log('Video started playing - static effect stopped');
        };

        // Button handlers
        document.getElementById('startButton').addEventListener('click', async () => {
            await createOffer();
            startStatsLogging();
            document.getElementById('sendOfferButton').disabled = false;
            log('Connection started. Enter server URL and station, then click "Send Offer to Server".');
        });

        document.getElementById('sendOfferButton').addEventListener('click', sendOfferToServer);

        document.getElementById('restartIceButton').addEventListener('click', restartIce);
    </script>
</body>
</html>